# **Тестовое задание для Middle NestJS разработчика**

Разработайте простое REST API с использованием NestJS, которое включает в себя аутентификацию, CRUD операции и кэширование данных. Проект должен использовать PostgreSQL для хранения данных и Redis для кэширования.

1. **Создание API для аутентификации:**
    - Реализуйте регистрацию и аутентификацию пользователей.
    - Используйте JWT (JSON Web Tokens) для обработки аутентификации.
2. **Интеграция с базой данных PostgreSQL с использованием TypeORM:**
    - Настройте соединение с базой данных.
    - Используйте миграции для управления структурой базы данных.
3. **Разработка CRUD API для сущности "Статья":**
    - Структура "Статьи" должна включать: название, описание, дату публикации, автора.
    - Реализуйте операции создания, чтения, обновления и удаления статей.
    - Обеспечьте валидацию входных данных.
    - Реализуйте пагинацию для запросов списка статей.
    - Добавьте возможность фильтрации статей по различным критериям (например, по дате публикации, автору).
    - Создание и обновление статей, должны быть закрыты авторизацией
4. **Реализация кэширования с использованием Redis:**
    - Кэшируйте результаты запросов на чтение статей.
    - Обеспечьте инвалидацию кэша при обновлении или удалении статей.
5. **Тестирование:**
    - Напишите unit-тесты для проверки бизнес-логики.
    
    ### Требования к коду и документации:
    
    - Код должен быть чистым, хорошо структурированным и легко читаемым.
    - Обеспечьте комментарии к коду и документацию API (по желанию) с примерами запросов и ответов.



# **Ответ на проделанную работу**

    Инфо по тестовому от проверяющего:
- Создал 1 миграцию на все сущности
- Бэк не шлёт ошибки только объекты {success: 0 | 1, message, data}
+ Реализован отдельный класс репозиторий для работы с бд
+ Реализован паттерн CQRS (Command Query Responsibility Segregation) Каждая точка вызывает команду Бизнес-логика разбита на команды (файлы) что повышает поиск конкретных кейсов
+- Создан файл Buisness-settings в котором описаны все валидации и константные значения. Идея не плохая, но это должен быть не 1 файл для всего, а отдельные каждый под свою область
- Сваггер не описан
- Сомнительная валиация енвов
- Проблема размазанности (описание пагинация артикулов находится м общем файле пагинация)


# **Мое мнение на ответ**
*Уточняю: мне сказали, что сделано все вполне хорошо, но я потребовал минусы, ради развития своих навыков, согласен я или нет - не имеет значения*

- Я как-то не понял, что нужно реализовывать несколько миграции( видимо под две сущности раздельно )
- Не было указания слать ошибки: ошибки валидации данных проходят через пайп глобально и возвращает BadRequestException, в случае ошибок в бизнес логике,  success возвращает булево значение, а в data передается объект со статусом при необходимости и/или иными полями. Реализация подобным образом должна была показать понимание различных возможностей ответа от сервера, хоть приводить в пример подобный уровень организации стыдно, тем не менее, реализация практикуется в WB
+
+
- Для демонстрации понимания важности единого места хранения определенных данных. Разбитие считаю логичным, согласен
- "... документацию API (по желанию) с примерами запросов и ответов". По желанию же.
- Согласен, хотя я не достаточно хорош, чтобы понять, как это делать без zod, а по какой причине я все таки от него отказался и вернулся к transform и validator, я уже не помню, но создавать проверку для девопса на длинну символов не считаю необходимым, поэтому просто проверяю наличие, возможно варварским методом (+ я не использую заглушки в конфиг сервисе, поэтому приложение рухнет без переменной, вместо некорректной/неожиданной работы)
- Согласен, можно было и посильнее дробить на файлы

